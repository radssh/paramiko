Change summary for auth_wip do-over of legacy AuthHandler

Separate out the client authentication flow from the individual
authentication methods. The flow, described in RFC4252 establishes
the SSH Authentication layer between the Transport and Connection
layers. While somewhat vague per the RFCs, servers do not permit
clients to request ssh-connection service directly, but instead
enable the ssh-connection service once the user authentication
phase is completed successfully.

Because the authentication protocol does not follow a strict sequence of
steps, and each step may involve different authentication mechanisms, in no
predetermined order, it can be difficult to adapt to a typical programmatic
sequence of steps. For example, sending a username/password may not be
sufficient, or might even be disallowed at the time the client (script)
chooses to send it. The server may be configured to require public key
authentication or other non-password based authentication such as a
time-based token (GoogleAuthenticator/Yubi) prior to progressing to
accepting a password.

The legacy AuthHandler model required the client portion to exclusively
use single authentication calls (Try this password/Try this key/etc) to
drive the authentication, instead of a mutual cooperation between client
and server. Further complicating code maintainability is the need to
internally morph the AuthHandler to accomodate the dynamic authentication
methods, and inability to sanely preserve state during the process, as
in some cases, the AuthHandler object would need to be reinstantiated.

This reimplementation is an attempt to consolidate the authentication flow
into a simpler, unified flow, and segregate out the individual Authentication
methods into compact, easier to maintain class objects.

Significant effort is made to preserve high-level backward compatibility
with existing code, but due to the general architecture of the new flow, not
all low-level underpinnings will be retained. Sorry.

Overview of Class changes:
Authenticator is intended to be an enhanced replacement for the legacy
AuthHandler class, for client authentication to a server. Server side
authentication of clients may be added at a later date, probably as a
distinct class, as the process flow behavior is significantly different.

The expected interaction, from the client side differs somewhat from
the legacy AuthHandler. Instead of requiring the client to explicitly make
calls to specific authentication methods, the Authenticator keeps track of
a more comprehensive suite of available authentication methods and parameters
to try, and the client need only call one "authenticate()" function to start
(and ideally, complete) the user authentication phase. If the process fails
to successfully authenticate the Transport, the client can offer subsequent
attempts either as a followup suite, or with individual single-method calls
as in the legacy AuthHandler. It is fully expected that the initial available
suite can be adequately assembled in such a way that subsequent calls will
not be necessary, except for permitting existing legacy code (that does not
call "authenticate()" at all) to still authenticate.

The capability of client getting asynchronous notification of stage completion
via Python Event objects is deprecated. Since an unauthenticated Transport is
not useful by itself prior to successful user authentication, the asynchronous
notification will not be supported. If clients do pass Events, they will be
signaled at the end of processing, but not asynchronously.

BadAuthenticationType and PartialAuthenticaiton exceptions will not be used
by the new Authenticator mechanism. Calls to "authenticate()", or
replacement "auth_xxxx()" methods should typically return True on successful
authentication (and set the Transport.authenticated attribute) or False,
indicating that the attempt(s) to authenticate have left the Transport in a
still unauthenticated state. In rare exceptions, AuthenticationException
can be raised, with detailed information included. Since the process flow
avoids the morphing behavior of AuthHandler, the construct for raising
deferred or saved_exceptions is also eliminated.

Much of the twiddling of low level options are now driven from OpenSSH
client configuration options, and can be updated with a single call passing
a dict with the options. For ease of use, the dict is expected to primarily
be the result of paramiko.SSHConfig.lookup(host) so these option settings can
be common between Paramiko and the ssh command line client. Manual construction
of the dict is also possible. Only the default setting for BatchMode deviates
from recent OpenSSH defaults, per "man ssh_config", as disabling user prompting
seems a more appropriate choice, based on existing Paramiko code.


Detailed Coding Comments (walkthrough of auth_handler)
Authenticator.__init__() takes transport parameter (as AuthHandler does), but
adds optional convenience parameters for username (SSH does not permit changing
username mid-authentication, so it does not make sense to require username
passed in to each individual authentication method) which defaults to the
current login user, as well as a password, key (PKey or filename) and passphrase
to use if the key is passed as a filename and requires a passphrase to decrypt.
In the cases where a password or key is sufficient to authenticate the user,
the client code can simply instantiate the Authenticator with the username
and password (or key), and call "authenticate()". Old style look_for_keys
and allow_agent options are not supported, but can be mimicked by the
OpenSSH configuration options IdentityFile, IdentitiesOnly, and IdentityAgent.

Authenticator retains a class member dict `ssh_options` holding default values
for authentication options. This is a subset of the OpenSSH client options,
and can be updated via `update_authentication_options` with a dict (ideally
from `paramiko.SSHConfig.lookup()`). This should effectively cover most of
the tweaking that would be handled by `authenticate_with_kwargs()`.

A new base class `AuthMethod` is constucted that handles the core basics
necessary to attempt one mechanism (combined with one set of parameters
specific to that particular mechanism). All `AuthMethod` objects should take
the first parameter as the reference to the parent `Authenticator`, and should
optionally list additional parameters specific to the implemented method:
a password for `AuthPassword`, a `PKey` for `AuthPublicKey`, etc.

Each implemented AuthMethod should also provide a (@classmethod) factory
callable to be used as an iterator to produce variations of usable AuthMethod
objects to be attempted for a given authentication mechanism. The flow
of `authenticate()` will make use of each produced AuthMethod. For example,
the AuthPassword factory can generate objects based on a provided list of
passwords to try, and if that list is fully consumed, fall back to
ineractively prompting for password at the console (conditional on the
setting of ssh_config `BatchMode` option). Similarly, keys (and certificates)
can be listed as filenames (or actual PKeys) based on settings such as
`IdentityFile` to produce a sensible sequence of keys to attempt. The provided
factory methods are intended to represent typical OpenSSH client behavior;
custom coded iterators can be used to drive the `authenticate()` process.

To drive the `authenticate()` processing, a local dict is prepared with
key lookups based on auth_method names, with the various AuthMethod iterators.
Like OpenSSH, the Authenticator will choose the next method name, as per the
client's `PreferredAuthentications` list, as long as that method name is
present in the dict, is included in the server's "can continue" list *(unless
the dict was explicitly supplied to `authenticate()`), and the iterator's
`next()` call returns a usable AuthMethod. Once selected as the current
AuthMethod, the initial `USERAUTH_REQUEST` is sent, with the `Authenticator`
handling responses of Success/Failure/Banner, with any other response
message being passed along to the specific AuthMethod.


Research Notes
OpenSSH source checking:
keyboard-interactive submethods do equate to option KbdInteractiveDevices
(sshconnect2.c:userauth_kbdint())

ChallengeResponseAuthentication (if set) supercedes KbdInteractiveAuthentication
in both sshd.c (server) and sshconnect2.c (client) modes

GSSAPI Patch (not from openssh-portable - reviewed CentOS SRPM gsskex.patch)
Priority of gss_host: GSSAPIServerIdentity/GSSAPITrustDNS/connection hostname
(or IP). DNS lookup for TrustDNS is extremely paranoid. Option for client
normalization (GSSAPIClientIdentity) candidate for support during Transport
GSSAPIKeyExchange
